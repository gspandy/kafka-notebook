# 4. kafka生产者分区策略

## 4.1 分区原因

### 方便在集群中扩展

每个Partition可以通过调整以适应它所在的机器

1个topic又可以有多个 Partition组成，因此整个集群就可以适应任意大小的数据了。

### 提高并发

因为可以以Partition为单位读写了。

## 4.2 分区原则

需要将 Producer发送的数据封装成1个 ProducerRecord对象

```
ProducerRecord(@NotNull String topic, Integer partition, Long timestamp, String key, String value, @Nullable Iterable<Header> headers)
ProducerRecord(@NotNull String topic, Integer partition, Long timestamp, String key, String value)
ProducerRecord(@NotNull String topic, Integer partition, String key, String value, @Nullable Iterable<Header> headers)
ProducerRecord(@NotNull String topic, String key, String value)
ProducerRecord(@NotNull String topic, String value)
```

### case 1: 指明 partition
如:
```
ProducerRecord(@NotNull String topic, Integer partition, Long timestamp, String key, String value, @Nullable Iterable<Header> headers)
ProducerRecord(@NotNull String topic, Integer partition, Long timestamp, String key, String value)
ProducerRecord(@NotNull String topic, Integer partition, String key, String value, @Nullable Iterable<Header> headers)
```

方法: 直接将 指明的值 直接作为 partition值


### case 2: 未指明 partition值，但有 key的情况下
如:
```
ProducerRecord(@NotNull String topic, String key, String value)
```

方法: 将 key 的 hash值与 topic 的 partition数进行取余得到 partition值

```
partition = hash(key) % total(partition)
```

### case 3: 既没有 partition值，又没有 key的值
如:

```
ProducerRecord(@NotNull String topic, String value)
```

方法: (round-robin算法)第1次调用时随机生成1个整数(后面每次调用在这个整数上递增)，将这个值与 topic可用的partition总数取余得到partition值


